CCS PCM C Compiler, Version 5.074, 32906               03-Apr-19 00:04

               Filename:   C:\Users\Natty\Desktop\Project\project.lst

               ROM used:   663 words (8%)
                           Largest free fragment is 2048
               RAM used:   64 (17%) at main() level
                           71 (19%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1E2
0003:  NOP
....................  
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0004:  DATA 73,3A
0005:  DATA 61,39
0006:  DATA 20,31
0007:  DATA 69,3A
0008:  DATA A0,18
0009:  DATA 0A,00
000A:  DATA 50,39
000B:  DATA EF,33
000C:  DATA F2,30
000D:  DATA 6D,10
000E:  DATA 73,3A
000F:  DATA 61,39
0010:  DATA F4,32
0011:  DATA E4,10
0012:  DATA 0A,00
0013:  DATA 49,37
0014:  DATA F0,3A
0015:  DATA 74,1D
0016:  DATA 0A,00
0017:  DATA D4,32
0018:  DATA 78,3A
0019:  DATA 20,36
001A:  DATA 65,37
001B:  DATA 67,3A
001C:  DATA 68,10
001D:  DATA E9,39
001E:  DATA A0,12
001F:  DATA 64,10
0020:  DATA 0A,00
0021:  DATA A5,31
0022:  DATA A0,1E
0023:  DATA 20,05
0024:  DATA 00,00
*
0039:  MOVF   0B,W
003A:  MOVWF  5D
003B:  BCF    0B.7
003C:  BSF    03.5
003D:  BSF    03.6
003E:  BSF    0C.7
003F:  BSF    0C.0
0040:  NOP
0041:  NOP
0042:  BCF    03.5
0043:  BCF    03.6
0044:  BTFSC  5D.7
0045:  BSF    0B.7
0046:  BSF    03.6
0047:  MOVF   0C,W
0048:  ANDLW  7F
0049:  BTFSC  03.2
004A:  GOTO   08F
004B:  BCF    03.6
004C:  MOVWF  5D
004D:  BSF    03.6
004E:  MOVF   0D,W
004F:  BCF    03.6
0050:  MOVWF  5E
0051:  BSF    03.6
0052:  MOVF   0F,W
0053:  BCF    03.6
0054:  MOVWF  5F
0055:  MOVF   5D,W
0056:  BTFSS  0C.4
0057:  GOTO   056
0058:  MOVWF  19
0059:  MOVF   5E,W
005A:  BSF    03.6
005B:  MOVWF  0D
005C:  BCF    03.6
005D:  MOVF   5F,W
005E:  BSF    03.6
005F:  MOVWF  0F
0060:  BCF    03.6
0061:  MOVF   0B,W
0062:  MOVWF  60
0063:  BCF    0B.7
0064:  BSF    03.5
0065:  BSF    03.6
0066:  BSF    0C.7
0067:  BSF    0C.0
0068:  NOP
0069:  NOP
006A:  BCF    03.5
006B:  BCF    03.6
006C:  BTFSC  60.7
006D:  BSF    0B.7
006E:  BSF    03.6
006F:  RLF    0C,W
0070:  RLF    0E,W
0071:  ANDLW  7F
0072:  BTFSC  03.2
0073:  GOTO   08F
0074:  BCF    03.6
0075:  MOVWF  5D
0076:  BSF    03.6
0077:  MOVF   0D,W
0078:  BCF    03.6
0079:  MOVWF  5E
007A:  BSF    03.6
007B:  MOVF   0F,W
007C:  BCF    03.6
007D:  MOVWF  5F
007E:  MOVF   5D,W
007F:  BTFSS  0C.4
0080:  GOTO   07F
0081:  MOVWF  19
0082:  MOVF   5E,W
0083:  BSF    03.6
0084:  MOVWF  0D
0085:  BCF    03.6
0086:  MOVF   5F,W
0087:  BSF    03.6
0088:  MOVWF  0F
0089:  INCF   0D,F
008A:  BTFSC  03.2
008B:  INCF   0F,F
008C:  BCF    03.6
008D:  GOTO   039
008E:  BSF    03.6
008F:  BCF    03.6
0090:  RETURN
*
00B1:  MOVF   0B,W
00B2:  MOVWF  5B
00B3:  BCF    0B.7
00B4:  BSF    03.5
00B5:  BSF    03.6
00B6:  BSF    0C.7
00B7:  BSF    0C.0
00B8:  NOP
00B9:  NOP
00BA:  BCF    03.5
00BB:  BCF    03.6
00BC:  BTFSC  5B.7
00BD:  BSF    0B.7
00BE:  BTFSC  03.0
00BF:  GOTO   0E9
00C0:  BSF    03.6
00C1:  MOVF   0C,W
00C2:  ANDLW  7F
00C3:  BCF    03.6
00C4:  MOVWF  5B
00C5:  BSF    03.6
00C6:  MOVF   0D,W
00C7:  BCF    03.6
00C8:  MOVWF  5C
00C9:  BSF    03.6
00CA:  MOVF   0F,W
00CB:  BCF    03.6
00CC:  MOVWF  5D
00CD:  MOVF   5B,W
00CE:  BTFSS  0C.4
00CF:  GOTO   0CE
00D0:  MOVWF  19
00D1:  MOVF   5C,W
00D2:  BSF    03.6
00D3:  MOVWF  0D
00D4:  BCF    03.6
00D5:  MOVF   5D,W
00D6:  BSF    03.6
00D7:  MOVWF  0F
00D8:  BCF    03.6
00D9:  MOVF   0B,W
00DA:  MOVWF  5E
00DB:  BCF    0B.7
00DC:  BSF    03.5
00DD:  BSF    03.6
00DE:  BSF    0C.7
00DF:  BSF    0C.0
00E0:  NOP
00E1:  NOP
00E2:  BCF    03.5
00E3:  BCF    03.6
00E4:  BTFSC  5E.7
00E5:  BSF    0B.7
00E6:  DECFSZ 5A,F
00E7:  GOTO   0E9
00E8:  GOTO   109
00E9:  BSF    03.6
00EA:  RLF    0C,W
00EB:  RLF    0E,W
00EC:  ANDLW  7F
00ED:  BCF    03.6
00EE:  MOVWF  5B
00EF:  BSF    03.6
00F0:  MOVF   0D,W
00F1:  BCF    03.6
00F2:  MOVWF  5C
00F3:  BSF    03.6
00F4:  MOVF   0F,W
00F5:  BCF    03.6
00F6:  MOVWF  5D
00F7:  MOVF   5B,W
00F8:  BTFSS  0C.4
00F9:  GOTO   0F8
00FA:  MOVWF  19
00FB:  MOVF   5C,W
00FC:  BSF    03.6
00FD:  MOVWF  0D
00FE:  BCF    03.6
00FF:  MOVF   5D,W
0100:  BSF    03.6
0101:  MOVWF  0F
0102:  INCF   0D,F
0103:  BTFSC  03.2
0104:  INCF   0F,F
0105:  BCF    03.0
0106:  BCF    03.6
0107:  DECFSZ 5A,F
0108:  GOTO   0B1
0109:  RETURN
010A:  MOVF   60,W
010B:  CLRF   78
010C:  SUBWF  5F,W
010D:  BTFSC  03.0
010E:  GOTO   112
010F:  MOVF   5F,W
0110:  MOVWF  77
0111:  GOTO   11E
0112:  CLRF   77
0113:  MOVLW  08
0114:  MOVWF  61
0115:  RLF    5F,F
0116:  RLF    77,F
0117:  MOVF   60,W
0118:  SUBWF  77,W
0119:  BTFSC  03.0
011A:  MOVWF  77
011B:  RLF    78,F
011C:  DECFSZ 61,F
011D:  GOTO   115
011E:  RETURN
011F:  MOVLW  20
0120:  BTFSS  5A.4
0121:  MOVLW  30
0122:  MOVWF  5B
0123:  MOVF   59,W
0124:  MOVWF  77
0125:  BTFSS  59.7
0126:  GOTO   12F
0127:  COMF   77,F
0128:  INCF   77,F
0129:  MOVF   77,W
012A:  MOVWF  59
012B:  MOVLW  2D
012C:  MOVWF  5B
012D:  BSF    5A.7
012E:  BSF    5A.0
012F:  MOVF   59,W
0130:  MOVWF  5F
0131:  MOVLW  64
0132:  MOVWF  60
0133:  CALL   10A
0134:  MOVF   77,W
0135:  MOVWF  59
0136:  MOVLW  30
0137:  ADDWF  78,W
0138:  MOVWF  5C
0139:  MOVF   59,W
013A:  MOVWF  5F
013B:  MOVLW  0A
013C:  MOVWF  60
013D:  CALL   10A
013E:  MOVLW  30
013F:  ADDWF  77,W
0140:  MOVWF  5E
0141:  MOVLW  30
0142:  ADDWF  78,W
0143:  MOVWF  5D
0144:  MOVF   5B,W
0145:  MOVWF  77
0146:  MOVLW  30
0147:  SUBWF  5C,W
0148:  BTFSC  03.2
0149:  GOTO   14E
014A:  BSF    5A.1
014B:  BTFSC  5A.7
014C:  BSF    5A.2
014D:  GOTO   162
014E:  MOVF   5B,W
014F:  MOVWF  5C
0150:  MOVLW  20
0151:  MOVWF  5B
0152:  MOVLW  30
0153:  SUBWF  5D,W
0154:  BTFSC  03.2
0155:  GOTO   15A
0156:  BSF    5A.0
0157:  BTFSC  5A.7
0158:  BSF    5A.1
0159:  GOTO   162
015A:  BTFSS  03.2
015B:  BSF    5A.0
015C:  BTFSS  03.2
015D:  GOTO   162
015E:  MOVF   5C,W
015F:  MOVWF  5D
0160:  MOVLW  20
0161:  MOVWF  5C
0162:  BTFSC  5A.2
0163:  GOTO   169
0164:  BTFSC  5A.1
0165:  GOTO   16D
0166:  BTFSC  5A.0
0167:  GOTO   171
0168:  GOTO   175
0169:  MOVF   5B,W
016A:  BTFSS  0C.4
016B:  GOTO   16A
016C:  MOVWF  19
016D:  MOVF   5C,W
016E:  BTFSS  0C.4
016F:  GOTO   16E
0170:  MOVWF  19
0171:  MOVF   5D,W
0172:  BTFSS  0C.4
0173:  GOTO   172
0174:  MOVWF  19
0175:  MOVF   5E,W
0176:  BTFSS  0C.4
0177:  GOTO   176
0178:  MOVWF  19
0179:  BCF    0A.3
017A:  BCF    0A.4
017B:  GOTO   251 (RETURN)
017C:  MOVF   00,F
017D:  BTFSC  03.2
017E:  GOTO   192
017F:  CLRF   5A
0180:  MOVF   04,W
0181:  MOVWF  59
0182:  BCF    5A.0
0183:  BTFSC  03.7
0184:  BSF    5A.0
0185:  MOVF   00,W
0186:  BTFSS  0C.4
0187:  GOTO   186
0188:  MOVWF  19
0189:  MOVF   59,W
018A:  MOVWF  04
018B:  BCF    03.7
018C:  BTFSC  5A.0
018D:  BSF    03.7
018E:  INCF   04,F
018F:  BTFSC  03.2
0190:  INCF   05,F
0191:  GOTO   17C
0192:  BCF    0A.3
0193:  BCF    0A.4
0194:  GOTO   264 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16   
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External SWITCH Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used FOR I/O 
.................... #FUSES NODEBUG                  //No Debug mode FOR ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
.................... #include <stdio.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0091:  MOVF   5A,W
0092:  MOVWF  5C
0093:  MOVF   59,W
0094:  MOVWF  5B
0095:  MOVF   5C,W
0096:  MOVWF  7A
0097:  MOVF   5B,W
0098:  MOVWF  04
0099:  BCF    03.7
009A:  BTFSC  7A.0
009B:  BSF    03.7
009C:  MOVF   00,F
009D:  BTFSC  03.2
009E:  GOTO   0A3
009F:  INCF   5B,F
00A0:  BTFSC  03.2
00A1:  INCF   5C,F
00A2:  GOTO   095
....................    return(sc - s); 
00A3:  MOVF   59,W
00A4:  SUBWF  5B,W
00A5:  MOVWF  77
00A6:  MOVF   5C,W
00A7:  MOVWF  7A
00A8:  MOVF   5A,W
00A9:  BTFSS  03.0
00AA:  INCFSZ 5A,W
00AB:  SUBWF  7A,F
00AC:  MOVF   77,W
00AD:  MOVWF  78
00AE:  BCF    0A.3
00AF:  BCF    0A.4
00B0:  GOTO   239 (RETURN)
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0208:  BCF    03.6
0209:  CLRF   20
020A:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock=8M) 
*
0025:  MOVLW  5D
0026:  MOVWF  04
0027:  BCF    03.7
0028:  MOVF   00,W
0029:  BTFSC  03.2
002A:  GOTO   038
002B:  MOVLW  02
002C:  MOVWF  78
002D:  CLRF   77
002E:  DECFSZ 77,F
002F:  GOTO   02E
0030:  DECFSZ 78,F
0031:  GOTO   02D
0032:  MOVLW  97
0033:  MOVWF  77
0034:  DECFSZ 77,F
0035:  GOTO   034
0036:  DECFSZ 00,F
0037:  GOTO   02B
0038:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... //!#include<string.h> 
.................... char text[50]; 
.................... int F=500; 
.................... void decToBinary(int n)  
.................... {  
....................      int  c, k; 
....................      output_high(PIN_B6); 
*
0195:  BSF    03.5
0196:  BCF    06.6
0197:  BCF    03.5
0198:  BSF    06.6
....................      printf("star bit 1\n"); 
0199:  MOVLW  04
019A:  BSF    03.6
019B:  MOVWF  0D
019C:  MOVLW  00
019D:  MOVWF  0F
019E:  BCF    03.6
019F:  CALL   039
....................      delay_ms(50); 
01A0:  MOVLW  32
01A1:  MOVWF  5D
01A2:  CALL   025
....................     for (c = 8; c > 0; c--) 
01A3:  MOVLW  08
01A4:  MOVWF  5B
01A5:  MOVF   5B,F
01A6:  BTFSC  03.2
01A7:  GOTO   1D4
....................   { 
....................    
....................     k = n >> (c-1); 
01A8:  MOVLW  01
01A9:  SUBWF  5B,W
01AA:  MOVWF  78
01AB:  MOVF   5A,W
01AC:  MOVWF  5C
01AD:  MOVF   78,F
01AE:  BTFSC  03.2
01AF:  GOTO   1B4
01B0:  BCF    03.0
01B1:  RRF    5C,F
01B2:  DECFSZ 78,F
01B3:  GOTO   1B0
....................   
....................     if (k & 1){ 
01B4:  BTFSS  5C.0
01B5:  GOTO   1C3
....................       printf("1\n"); 
01B6:  MOVLW  31
01B7:  BTFSS  0C.4
01B8:  GOTO   1B7
01B9:  MOVWF  19
01BA:  MOVLW  0A
01BB:  BTFSS  0C.4
01BC:  GOTO   1BB
01BD:  MOVWF  19
....................       output_high(PIN_B6);} 
01BE:  BSF    03.5
01BF:  BCF    06.6
01C0:  BCF    03.5
01C1:  BSF    06.6
01C2:  GOTO   1CF
....................     else{ 
....................       printf("0\n"); 
01C3:  MOVLW  30
01C4:  BTFSS  0C.4
01C5:  GOTO   1C4
01C6:  MOVWF  19
01C7:  MOVLW  0A
01C8:  BTFSS  0C.4
01C9:  GOTO   1C8
01CA:  MOVWF  19
....................       output_low(PIN_B6); 
01CB:  BSF    03.5
01CC:  BCF    06.6
01CD:  BCF    03.5
01CE:  BCF    06.6
....................     } 
....................        
....................       delay_ms(50); 
01CF:  MOVLW  32
01D0:  MOVWF  5D
01D1:  CALL   025
01D2:  DECF   5B,F
01D3:  GOTO   1A5
....................   } 
....................   output_low(PIN_B6); 
01D4:  BSF    03.5
01D5:  BCF    06.6
01D6:  BCF    03.5
01D7:  BCF    06.6
....................   delay_ms(50); 
01D8:  MOVLW  32
01D9:  MOVWF  5D
01DA:  CALL   025
....................   printf("\n"); 
01DB:  MOVLW  0A
01DC:  BTFSS  0C.4
01DD:  GOTO   1DC
01DE:  MOVWF  19
01DF:  BCF    0A.3
01E0:  BCF    0A.4
01E1:  GOTO   293 (RETURN)
....................  
.................... } 
.................... void main(){ 
01E2:  MOVF   03,W
01E3:  ANDLW  1F
01E4:  MOVWF  03
01E5:  MOVLW  71
01E6:  BSF    03.5
01E7:  MOVWF  0F
01E8:  CLRF   10
01E9:  MOVF   0F,W
01EA:  BSF    03.6
01EB:  BCF    07.3
01EC:  MOVLW  0C
01ED:  BCF    03.6
01EE:  MOVWF  19
01EF:  MOVLW  A2
01F0:  MOVWF  18
01F1:  MOVLW  90
01F2:  BCF    03.5
01F3:  MOVWF  18
01F4:  MOVLW  F4
01F5:  MOVWF  54
01F6:  CLRF   56
01F7:  CLRF   55
01F8:  BSF    03.5
01F9:  BSF    03.6
01FA:  MOVF   09,W
01FB:  ANDLW  C0
01FC:  MOVWF  09
01FD:  BCF    03.6
01FE:  BCF    1F.4
01FF:  BCF    1F.5
0200:  MOVLW  00
0201:  BSF    03.6
0202:  MOVWF  08
0203:  BCF    03.5
0204:  CLRF   07
0205:  CLRF   08
0206:  CLRF   09
0207:  BCF    03.7
....................    delay_ms(2000); 
*
020B:  MOVLW  08
020C:  MOVWF  59
020D:  MOVLW  FA
020E:  MOVWF  5D
020F:  CALL   025
0210:  DECFSZ 59,F
0211:  GOTO   20D
....................    printf("Program started!\n"); 
0212:  MOVLW  0A
0213:  BSF    03.6
0214:  MOVWF  0D
0215:  MOVLW  00
0216:  MOVWF  0F
0217:  BCF    03.6
0218:  CALL   039
....................    delay_ms(1000); 
0219:  MOVLW  04
021A:  MOVWF  59
021B:  MOVLW  FA
021C:  MOVWF  5D
021D:  CALL   025
021E:  DECFSZ 59,F
021F:  GOTO   21B
.................... //!   printf("Input Frequency:\n"); 
.................... //!   scanf("%d",&F); 
....................    while(1){ 
....................     printf("Input:\n"); 
0220:  MOVLW  13
0221:  BSF    03.6
0222:  MOVWF  0D
0223:  MOVLW  00
0224:  MOVWF  0F
0225:  BCF    03.6
0226:  CALL   039
....................   gets(text);  
0227:  MOVLW  22
0228:  MOVWF  04
0229:  BCF    03.7
022A:  DECF   04,F
022B:  INCF   04,F
022C:  BTFSS  0C.5
022D:  GOTO   22C
022E:  MOVF   1A,W
022F:  MOVWF  00
0230:  MOVLW  0D
0231:  SUBWF  00,W
0232:  BTFSS  03.2
0233:  GOTO   22B
0234:  CLRF   00
....................    int length=strlen(text); 
....................    int i; 
0235:  CLRF   5A
0236:  MOVLW  22
0237:  MOVWF  59
0238:  GOTO   091
0239:  MOVF   78,W
023A:  MOVWF  57
....................    delay_ms(1000); 
023B:  MOVLW  04
023C:  MOVWF  59
023D:  MOVLW  FA
023E:  MOVWF  5D
023F:  CALL   025
0240:  DECFSZ 59,F
0241:  GOTO   23D
....................    printf("Text length is %d \n",length); 
0242:  MOVLW  17
0243:  BSF    03.6
0244:  MOVWF  0D
0245:  MOVLW  00
0246:  MOVWF  0F
0247:  BCF    03.0
0248:  MOVLW  0F
0249:  BCF    03.6
024A:  MOVWF  5A
024B:  CALL   0B1
024C:  MOVF   57,W
024D:  MOVWF  59
024E:  MOVLW  18
024F:  MOVWF  5A
0250:  GOTO   11F
0251:  MOVLW  20
0252:  BTFSS  0C.4
0253:  GOTO   252
0254:  MOVWF  19
0255:  MOVLW  0A
0256:  BTFSS  0C.4
0257:  GOTO   256
0258:  MOVWF  19
....................    delay_ms(1000); 
0259:  MOVLW  04
025A:  MOVWF  59
025B:  MOVLW  FA
025C:  MOVWF  5D
025D:  CALL   025
025E:  DECFSZ 59,F
025F:  GOTO   25B
....................    printf("%s \n",text); 
0260:  MOVLW  22
0261:  MOVWF  04
0262:  BCF    03.7
0263:  GOTO   17C
0264:  MOVLW  20
0265:  BTFSS  0C.4
0266:  GOTO   265
0267:  MOVWF  19
0268:  MOVLW  0A
0269:  BTFSS  0C.4
026A:  GOTO   269
026B:  MOVWF  19
....................    text[length]='\n'; 
026C:  MOVLW  22
026D:  ADDWF  57,W
026E:  MOVWF  04
026F:  BCF    03.7
0270:  MOVLW  0A
0271:  MOVWF  00
....................       for (i = 0; i <= length; i++) 
0272:  CLRF   58
0273:  MOVF   58,W
0274:  SUBWF  57,W
0275:  BTFSS  03.0
0276:  GOTO   295
....................       { 
....................          printf ("%c = \n", text[i]); 
0277:  MOVLW  22
0278:  ADDWF  58,W
0279:  MOVWF  04
027A:  BCF    03.7
027B:  MOVF   00,W
027C:  MOVWF  59
027D:  MOVF   59,W
027E:  BTFSS  0C.4
027F:  GOTO   27E
0280:  MOVWF  19
0281:  MOVLW  22
0282:  BSF    03.6
0283:  MOVWF  0D
0284:  MOVLW  00
0285:  MOVWF  0F
0286:  BCF    03.0
0287:  MOVLW  04
0288:  BCF    03.6
0289:  MOVWF  5A
028A:  CALL   0B1
....................          decToBinary((int)text[i]); 
028B:  MOVLW  22
028C:  ADDWF  58,W
028D:  MOVWF  04
028E:  BCF    03.7
028F:  MOVF   00,W
0290:  MOVWF  59
0291:  MOVWF  5A
0292:  GOTO   195
0293:  INCF   58,F
0294:  GOTO   273
....................       } 
0295:  GOTO   220
....................    } 
....................  
.................... } 
0296:  SLEEP

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
