CCS PCM C Compiler, Version 5.074, 32906               17-Apr-19 23:49

               Filename:   C:\Users\theka\OneDrive\Desktop\DataTransmissionModel\OldCode\project.lst

               ROM used:   723 words (9%)
                           Largest free fragment is 2048
               RAM used:   64 (17%) at main() level
                           71 (19%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1FC
0003:  NOP
....................  
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0004:  DATA 73,3A
0005:  DATA 61,39
0006:  DATA 20,31
0007:  DATA 69,3A
0008:  DATA A0,18
0009:  DATA 0A,00
000A:  DATA 50,39
000B:  DATA EF,33
000C:  DATA F2,30
000D:  DATA 6D,10
000E:  DATA 73,3A
000F:  DATA 61,39
0010:  DATA F4,32
0011:  DATA E4,10
0012:  DATA 0A,00
0013:  DATA C1,3A
0014:  DATA F4,37
0015:  DATA A0,31
0016:  DATA 61,39
0017:  DATA F2,34
0018:  DATA 62,39
0019:  DATA 61,3A
001A:  DATA 65,10
001B:  DATA A0,39
001C:  DATA F4,30
001D:  DATA 72,3A
001E:  DATA 65,32
001F:  DATA 21,05
0020:  DATA 00,01
0021:  DATA C1,3A
0022:  DATA F4,37
0023:  DATA A0,31
0024:  DATA 61,39
0025:  DATA F2,34
0026:  DATA 62,39
0027:  DATA 61,3A
0028:  DATA 65,10
0029:  DATA A0,22
002A:  DATA 6E,32
002B:  DATA 21,05
002C:  DATA 00,01
002D:  DATA 49,37
002E:  DATA F0,3A
002F:  DATA 74,1D
0030:  DATA 0A,00
0031:  DATA D4,32
0032:  DATA 78,3A
0033:  DATA 20,36
0034:  DATA 65,37
0035:  DATA 67,3A
0036:  DATA 68,10
0037:  DATA E9,39
0038:  DATA A0,12
0039:  DATA 64,10
003A:  DATA 0A,00
003B:  DATA A5,31
003C:  DATA A0,1E
003D:  DATA 20,05
003E:  DATA 00,00
*
0053:  MOVF   0B,W
0054:  MOVWF  5D
0055:  BCF    0B.7
0056:  BSF    03.5
0057:  BSF    03.6
0058:  BSF    0C.7
0059:  BSF    0C.0
005A:  NOP
005B:  NOP
005C:  BCF    03.5
005D:  BCF    03.6
005E:  BTFSC  5D.7
005F:  BSF    0B.7
0060:  BSF    03.6
0061:  MOVF   0C,W
0062:  ANDLW  7F
0063:  BTFSC  03.2
0064:  GOTO   0A9
0065:  BCF    03.6
0066:  MOVWF  5D
0067:  BSF    03.6
0068:  MOVF   0D,W
0069:  BCF    03.6
006A:  MOVWF  5E
006B:  BSF    03.6
006C:  MOVF   0F,W
006D:  BCF    03.6
006E:  MOVWF  5F
006F:  MOVF   5D,W
0070:  BTFSS  0C.4
0071:  GOTO   070
0072:  MOVWF  19
0073:  MOVF   5E,W
0074:  BSF    03.6
0075:  MOVWF  0D
0076:  BCF    03.6
0077:  MOVF   5F,W
0078:  BSF    03.6
0079:  MOVWF  0F
007A:  BCF    03.6
007B:  MOVF   0B,W
007C:  MOVWF  60
007D:  BCF    0B.7
007E:  BSF    03.5
007F:  BSF    03.6
0080:  BSF    0C.7
0081:  BSF    0C.0
0082:  NOP
0083:  NOP
0084:  BCF    03.5
0085:  BCF    03.6
0086:  BTFSC  60.7
0087:  BSF    0B.7
0088:  BSF    03.6
0089:  RLF    0C,W
008A:  RLF    0E,W
008B:  ANDLW  7F
008C:  BTFSC  03.2
008D:  GOTO   0A9
008E:  BCF    03.6
008F:  MOVWF  5D
0090:  BSF    03.6
0091:  MOVF   0D,W
0092:  BCF    03.6
0093:  MOVWF  5E
0094:  BSF    03.6
0095:  MOVF   0F,W
0096:  BCF    03.6
0097:  MOVWF  5F
0098:  MOVF   5D,W
0099:  BTFSS  0C.4
009A:  GOTO   099
009B:  MOVWF  19
009C:  MOVF   5E,W
009D:  BSF    03.6
009E:  MOVWF  0D
009F:  BCF    03.6
00A0:  MOVF   5F,W
00A1:  BSF    03.6
00A2:  MOVWF  0F
00A3:  INCF   0D,F
00A4:  BTFSC  03.2
00A5:  INCF   0F,F
00A6:  BCF    03.6
00A7:  GOTO   053
00A8:  BSF    03.6
00A9:  BCF    03.6
00AA:  RETURN
*
00CB:  MOVF   0B,W
00CC:  MOVWF  5B
00CD:  BCF    0B.7
00CE:  BSF    03.5
00CF:  BSF    03.6
00D0:  BSF    0C.7
00D1:  BSF    0C.0
00D2:  NOP
00D3:  NOP
00D4:  BCF    03.5
00D5:  BCF    03.6
00D6:  BTFSC  5B.7
00D7:  BSF    0B.7
00D8:  BTFSC  03.0
00D9:  GOTO   103
00DA:  BSF    03.6
00DB:  MOVF   0C,W
00DC:  ANDLW  7F
00DD:  BCF    03.6
00DE:  MOVWF  5B
00DF:  BSF    03.6
00E0:  MOVF   0D,W
00E1:  BCF    03.6
00E2:  MOVWF  5C
00E3:  BSF    03.6
00E4:  MOVF   0F,W
00E5:  BCF    03.6
00E6:  MOVWF  5D
00E7:  MOVF   5B,W
00E8:  BTFSS  0C.4
00E9:  GOTO   0E8
00EA:  MOVWF  19
00EB:  MOVF   5C,W
00EC:  BSF    03.6
00ED:  MOVWF  0D
00EE:  BCF    03.6
00EF:  MOVF   5D,W
00F0:  BSF    03.6
00F1:  MOVWF  0F
00F2:  BCF    03.6
00F3:  MOVF   0B,W
00F4:  MOVWF  5E
00F5:  BCF    0B.7
00F6:  BSF    03.5
00F7:  BSF    03.6
00F8:  BSF    0C.7
00F9:  BSF    0C.0
00FA:  NOP
00FB:  NOP
00FC:  BCF    03.5
00FD:  BCF    03.6
00FE:  BTFSC  5E.7
00FF:  BSF    0B.7
0100:  DECFSZ 5A,F
0101:  GOTO   103
0102:  GOTO   123
0103:  BSF    03.6
0104:  RLF    0C,W
0105:  RLF    0E,W
0106:  ANDLW  7F
0107:  BCF    03.6
0108:  MOVWF  5B
0109:  BSF    03.6
010A:  MOVF   0D,W
010B:  BCF    03.6
010C:  MOVWF  5C
010D:  BSF    03.6
010E:  MOVF   0F,W
010F:  BCF    03.6
0110:  MOVWF  5D
0111:  MOVF   5B,W
0112:  BTFSS  0C.4
0113:  GOTO   112
0114:  MOVWF  19
0115:  MOVF   5C,W
0116:  BSF    03.6
0117:  MOVWF  0D
0118:  BCF    03.6
0119:  MOVF   5D,W
011A:  BSF    03.6
011B:  MOVWF  0F
011C:  INCF   0D,F
011D:  BTFSC  03.2
011E:  INCF   0F,F
011F:  BCF    03.0
0120:  BCF    03.6
0121:  DECFSZ 5A,F
0122:  GOTO   0CB
0123:  RETURN
0124:  MOVF   60,W
0125:  CLRF   78
0126:  SUBWF  5F,W
0127:  BTFSC  03.0
0128:  GOTO   12C
0129:  MOVF   5F,W
012A:  MOVWF  77
012B:  GOTO   138
012C:  CLRF   77
012D:  MOVLW  08
012E:  MOVWF  61
012F:  RLF    5F,F
0130:  RLF    77,F
0131:  MOVF   60,W
0132:  SUBWF  77,W
0133:  BTFSC  03.0
0134:  MOVWF  77
0135:  RLF    78,F
0136:  DECFSZ 61,F
0137:  GOTO   12F
0138:  RETURN
0139:  MOVLW  20
013A:  BTFSS  5A.4
013B:  MOVLW  30
013C:  MOVWF  5B
013D:  MOVF   59,W
013E:  MOVWF  77
013F:  BTFSS  59.7
0140:  GOTO   149
0141:  COMF   77,F
0142:  INCF   77,F
0143:  MOVF   77,W
0144:  MOVWF  59
0145:  MOVLW  2D
0146:  MOVWF  5B
0147:  BSF    5A.7
0148:  BSF    5A.0
0149:  MOVF   59,W
014A:  MOVWF  5F
014B:  MOVLW  64
014C:  MOVWF  60
014D:  CALL   124
014E:  MOVF   77,W
014F:  MOVWF  59
0150:  MOVLW  30
0151:  ADDWF  78,W
0152:  MOVWF  5C
0153:  MOVF   59,W
0154:  MOVWF  5F
0155:  MOVLW  0A
0156:  MOVWF  60
0157:  CALL   124
0158:  MOVLW  30
0159:  ADDWF  77,W
015A:  MOVWF  5E
015B:  MOVLW  30
015C:  ADDWF  78,W
015D:  MOVWF  5D
015E:  MOVF   5B,W
015F:  MOVWF  77
0160:  MOVLW  30
0161:  SUBWF  5C,W
0162:  BTFSC  03.2
0163:  GOTO   168
0164:  BSF    5A.1
0165:  BTFSC  5A.7
0166:  BSF    5A.2
0167:  GOTO   17C
0168:  MOVF   5B,W
0169:  MOVWF  5C
016A:  MOVLW  20
016B:  MOVWF  5B
016C:  MOVLW  30
016D:  SUBWF  5D,W
016E:  BTFSC  03.2
016F:  GOTO   174
0170:  BSF    5A.0
0171:  BTFSC  5A.7
0172:  BSF    5A.1
0173:  GOTO   17C
0174:  BTFSS  03.2
0175:  BSF    5A.0
0176:  BTFSS  03.2
0177:  GOTO   17C
0178:  MOVF   5C,W
0179:  MOVWF  5D
017A:  MOVLW  20
017B:  MOVWF  5C
017C:  BTFSC  5A.2
017D:  GOTO   183
017E:  BTFSC  5A.1
017F:  GOTO   187
0180:  BTFSC  5A.0
0181:  GOTO   18B
0182:  GOTO   18F
0183:  MOVF   5B,W
0184:  BTFSS  0C.4
0185:  GOTO   184
0186:  MOVWF  19
0187:  MOVF   5C,W
0188:  BTFSS  0C.4
0189:  GOTO   188
018A:  MOVWF  19
018B:  MOVF   5D,W
018C:  BTFSS  0C.4
018D:  GOTO   18C
018E:  MOVWF  19
018F:  MOVF   5E,W
0190:  BTFSS  0C.4
0191:  GOTO   190
0192:  MOVWF  19
0193:  BCF    0A.3
0194:  BCF    0A.4
0195:  GOTO   28D (RETURN)
0196:  MOVF   00,F
0197:  BTFSC  03.2
0198:  GOTO   1AC
0199:  CLRF   5A
019A:  MOVF   04,W
019B:  MOVWF  59
019C:  BCF    5A.0
019D:  BTFSC  03.7
019E:  BSF    5A.0
019F:  MOVF   00,W
01A0:  BTFSS  0C.4
01A1:  GOTO   1A0
01A2:  MOVWF  19
01A3:  MOVF   59,W
01A4:  MOVWF  04
01A5:  BCF    03.7
01A6:  BTFSC  5A.0
01A7:  BSF    03.7
01A8:  INCF   04,F
01A9:  BTFSC  03.2
01AA:  INCF   05,F
01AB:  GOTO   196
01AC:  BCF    0A.3
01AD:  BCF    0A.4
01AE:  GOTO   2A0 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16   
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External SWITCH Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used FOR I/O 
.................... #FUSES NODEBUG                  //No Debug mode FOR ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
.................... #include <stdio.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
00AB:  MOVF   5A,W
00AC:  MOVWF  5C
00AD:  MOVF   59,W
00AE:  MOVWF  5B
00AF:  MOVF   5C,W
00B0:  MOVWF  7A
00B1:  MOVF   5B,W
00B2:  MOVWF  04
00B3:  BCF    03.7
00B4:  BTFSC  7A.0
00B5:  BSF    03.7
00B6:  MOVF   00,F
00B7:  BTFSC  03.2
00B8:  GOTO   0BD
00B9:  INCF   5B,F
00BA:  BTFSC  03.2
00BB:  INCF   5C,F
00BC:  GOTO   0AF
....................    return(sc - s); 
00BD:  MOVF   59,W
00BE:  SUBWF  5B,W
00BF:  MOVWF  77
00C0:  MOVF   5C,W
00C1:  MOVWF  7A
00C2:  MOVF   5A,W
00C3:  BTFSS  03.0
00C4:  INCFSZ 5A,W
00C5:  SUBWF  7A,F
00C6:  MOVF   77,W
00C7:  MOVWF  78
00C8:  BCF    0A.3
00C9:  BCF    0A.4
00CA:  GOTO   275 (RETURN)
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0220:  BCF    03.6
0221:  CLRF   20
0222:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock=8M) 
*
003F:  MOVLW  5D
0040:  MOVWF  04
0041:  BCF    03.7
0042:  MOVF   00,W
0043:  BTFSC  03.2
0044:  GOTO   052
0045:  MOVLW  02
0046:  MOVWF  78
0047:  CLRF   77
0048:  DECFSZ 77,F
0049:  GOTO   048
004A:  DECFSZ 78,F
004B:  GOTO   047
004C:  MOVLW  97
004D:  MOVWF  77
004E:  DECFSZ 77,F
004F:  GOTO   04E
0050:  DECFSZ 00,F
0051:  GOTO   045
0052:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... //!#include<string.h> 
.................... char text[50]; 
.................... void decToBinary(int n)  
.................... {  
....................      int  c, k; 
....................      output_high(PIN_B6); 
*
01AF:  BSF    03.5
01B0:  BCF    06.6
01B1:  BCF    03.5
01B2:  BSF    06.6
....................      printf("star bit 1\n"); 
01B3:  MOVLW  04
01B4:  BSF    03.6
01B5:  MOVWF  0D
01B6:  MOVLW  00
01B7:  MOVWF  0F
01B8:  BCF    03.6
01B9:  CALL   053
....................      delay_ms(50); 
01BA:  MOVLW  32
01BB:  MOVWF  5D
01BC:  CALL   03F
....................     for (c = 8; c > 0; c--) 
01BD:  MOVLW  08
01BE:  MOVWF  5B
01BF:  MOVF   5B,F
01C0:  BTFSC  03.2
01C1:  GOTO   1EE
....................   { 
....................    
....................     k = n >> (c-1); 
01C2:  MOVLW  01
01C3:  SUBWF  5B,W
01C4:  MOVWF  78
01C5:  MOVF   5A,W
01C6:  MOVWF  5C
01C7:  MOVF   78,F
01C8:  BTFSC  03.2
01C9:  GOTO   1CE
01CA:  BCF    03.0
01CB:  RRF    5C,F
01CC:  DECFSZ 78,F
01CD:  GOTO   1CA
....................   
....................     if (k & 1){ 
01CE:  BTFSS  5C.0
01CF:  GOTO   1DD
....................       printf("1\n"); 
01D0:  MOVLW  31
01D1:  BTFSS  0C.4
01D2:  GOTO   1D1
01D3:  MOVWF  19
01D4:  MOVLW  0A
01D5:  BTFSS  0C.4
01D6:  GOTO   1D5
01D7:  MOVWF  19
....................       output_high(PIN_B6);} 
01D8:  BSF    03.5
01D9:  BCF    06.6
01DA:  BCF    03.5
01DB:  BSF    06.6
01DC:  GOTO   1E9
....................     else{ 
....................       printf("0\n"); 
01DD:  MOVLW  30
01DE:  BTFSS  0C.4
01DF:  GOTO   1DE
01E0:  MOVWF  19
01E1:  MOVLW  0A
01E2:  BTFSS  0C.4
01E3:  GOTO   1E2
01E4:  MOVWF  19
....................       output_low(PIN_B6); 
01E5:  BSF    03.5
01E6:  BCF    06.6
01E7:  BCF    03.5
01E8:  BCF    06.6
....................     } 
....................        
....................       delay_ms(50); 
01E9:  MOVLW  32
01EA:  MOVWF  5D
01EB:  CALL   03F
01EC:  DECF   5B,F
01ED:  GOTO   1BF
....................   } 
....................   output_low(PIN_B6); 
01EE:  BSF    03.5
01EF:  BCF    06.6
01F0:  BCF    03.5
01F1:  BCF    06.6
....................   delay_ms(50); 
01F2:  MOVLW  32
01F3:  MOVWF  5D
01F4:  CALL   03F
....................   printf("\n"); 
01F5:  MOVLW  0A
01F6:  BTFSS  0C.4
01F7:  GOTO   1F6
01F8:  MOVWF  19
01F9:  BCF    0A.3
01FA:  BCF    0A.4
01FB:  GOTO   2CF (RETURN)
....................  
.................... } 
.................... void main(){ 
01FC:  MOVF   03,W
01FD:  ANDLW  1F
01FE:  MOVWF  03
01FF:  MOVLW  71
0200:  BSF    03.5
0201:  MOVWF  0F
0202:  CLRF   10
0203:  MOVF   0F,W
0204:  BSF    03.6
0205:  BCF    07.3
0206:  MOVLW  0C
0207:  BCF    03.6
0208:  MOVWF  19
0209:  MOVLW  A2
020A:  MOVWF  18
020B:  MOVLW  90
020C:  BCF    03.5
020D:  MOVWF  18
020E:  CLRF   55
020F:  CLRF   54
0210:  BSF    03.5
0211:  BSF    03.6
0212:  MOVF   09,W
0213:  ANDLW  C0
0214:  MOVWF  09
0215:  BCF    03.6
0216:  BCF    1F.4
0217:  BCF    1F.5
0218:  MOVLW  00
0219:  BSF    03.6
021A:  MOVWF  08
021B:  BCF    03.5
021C:  CLRF   07
021D:  CLRF   08
021E:  CLRF   09
021F:  BCF    03.7
....................    delay_ms(2000); 
*
0223:  MOVLW  08
0224:  MOVWF  59
0225:  MOVLW  FA
0226:  MOVWF  5D
0227:  CALL   03F
0228:  DECFSZ 59,F
0229:  GOTO   225
....................    printf("Program started!\n"); 
022A:  MOVLW  0A
022B:  BSF    03.6
022C:  MOVWF  0D
022D:  MOVLW  00
022E:  MOVWF  0F
022F:  BCF    03.6
0230:  CALL   053
....................     
....................    printf("Auto carribrate  started!\n"); 
0231:  MOVLW  13
0232:  BSF    03.6
0233:  MOVWF  0D
0234:  MOVLW  00
0235:  MOVWF  0F
0236:  BCF    03.6
0237:  CALL   053
....................    int n=0; 
0238:  CLRF   56
....................    for (n = 0; n < 50; n++) 
0239:  CLRF   56
023A:  MOVF   56,W
023B:  SUBLW  31
023C:  BTFSS  03.0
023D:  GOTO   24E
....................    { 
....................       output_high(PIN_B6); 
023E:  BSF    03.5
023F:  BCF    06.6
0240:  BCF    03.5
0241:  BSF    06.6
....................       delay_ms(50); 
0242:  MOVLW  32
0243:  MOVWF  5D
0244:  CALL   03F
....................       output_low(PIN_B6); 
0245:  BSF    03.5
0246:  BCF    06.6
0247:  BCF    03.5
0248:  BCF    06.6
....................       delay_ms(50); 
0249:  MOVLW  32
024A:  MOVWF  5D
024B:  CALL   03F
024C:  INCF   56,F
024D:  GOTO   23A
....................    } 
....................     printf("Auto carribrate  End!\n"); 
024E:  MOVLW  21
024F:  BSF    03.6
0250:  MOVWF  0D
0251:  MOVLW  00
0252:  MOVWF  0F
0253:  BCF    03.6
0254:  CALL   053
....................     
....................    delay_ms(1000); 
0255:  MOVLW  04
0256:  MOVWF  59
0257:  MOVLW  FA
0258:  MOVWF  5D
0259:  CALL   03F
025A:  DECFSZ 59,F
025B:  GOTO   257
.................... //!   printf("Input Frequency:\n"); 
.................... //!   scanf("%d",&F); 
....................    while(1){ 
....................     printf("Input:\n"); 
025C:  MOVLW  2D
025D:  BSF    03.6
025E:  MOVWF  0D
025F:  MOVLW  00
0260:  MOVWF  0F
0261:  BCF    03.6
0262:  CALL   053
....................   gets(text);  
0263:  MOVLW  22
0264:  MOVWF  04
0265:  BCF    03.7
0266:  DECF   04,F
0267:  INCF   04,F
0268:  BTFSS  0C.5
0269:  GOTO   268
026A:  MOVF   1A,W
026B:  MOVWF  00
026C:  MOVLW  0D
026D:  SUBWF  00,W
026E:  BTFSS  03.2
026F:  GOTO   267
0270:  CLRF   00
....................    int length=strlen(text); 
....................    int i; 
0271:  CLRF   5A
0272:  MOVLW  22
0273:  MOVWF  59
0274:  GOTO   0AB
0275:  MOVF   78,W
0276:  MOVWF  57
....................    delay_ms(1000); 
0277:  MOVLW  04
0278:  MOVWF  59
0279:  MOVLW  FA
027A:  MOVWF  5D
027B:  CALL   03F
027C:  DECFSZ 59,F
027D:  GOTO   279
....................    printf("Text length is %d \n",length); 
027E:  MOVLW  31
027F:  BSF    03.6
0280:  MOVWF  0D
0281:  MOVLW  00
0282:  MOVWF  0F
0283:  BCF    03.0
0284:  MOVLW  0F
0285:  BCF    03.6
0286:  MOVWF  5A
0287:  CALL   0CB
0288:  MOVF   57,W
0289:  MOVWF  59
028A:  MOVLW  18
028B:  MOVWF  5A
028C:  GOTO   139
028D:  MOVLW  20
028E:  BTFSS  0C.4
028F:  GOTO   28E
0290:  MOVWF  19
0291:  MOVLW  0A
0292:  BTFSS  0C.4
0293:  GOTO   292
0294:  MOVWF  19
....................    delay_ms(1000); 
0295:  MOVLW  04
0296:  MOVWF  59
0297:  MOVLW  FA
0298:  MOVWF  5D
0299:  CALL   03F
029A:  DECFSZ 59,F
029B:  GOTO   297
....................    printf("%s \n",text); 
029C:  MOVLW  22
029D:  MOVWF  04
029E:  BCF    03.7
029F:  GOTO   196
02A0:  MOVLW  20
02A1:  BTFSS  0C.4
02A2:  GOTO   2A1
02A3:  MOVWF  19
02A4:  MOVLW  0A
02A5:  BTFSS  0C.4
02A6:  GOTO   2A5
02A7:  MOVWF  19
....................    text[length]='\n'; 
02A8:  MOVLW  22
02A9:  ADDWF  57,W
02AA:  MOVWF  04
02AB:  BCF    03.7
02AC:  MOVLW  0A
02AD:  MOVWF  00
....................       for (i = 0; i <= length; i++) 
02AE:  CLRF   58
02AF:  MOVF   58,W
02B0:  SUBWF  57,W
02B1:  BTFSS  03.0
02B2:  GOTO   2D1
....................       { 
....................          printf ("%c = \n", text[i]); 
02B3:  MOVLW  22
02B4:  ADDWF  58,W
02B5:  MOVWF  04
02B6:  BCF    03.7
02B7:  MOVF   00,W
02B8:  MOVWF  59
02B9:  MOVF   59,W
02BA:  BTFSS  0C.4
02BB:  GOTO   2BA
02BC:  MOVWF  19
02BD:  MOVLW  3C
02BE:  BSF    03.6
02BF:  MOVWF  0D
02C0:  MOVLW  00
02C1:  MOVWF  0F
02C2:  BCF    03.0
02C3:  MOVLW  04
02C4:  BCF    03.6
02C5:  MOVWF  5A
02C6:  CALL   0CB
....................          decToBinary((int)text[i]); 
02C7:  MOVLW  22
02C8:  ADDWF  58,W
02C9:  MOVWF  04
02CA:  BCF    03.7
02CB:  MOVF   00,W
02CC:  MOVWF  59
02CD:  MOVWF  5A
02CE:  GOTO   1AF
02CF:  INCF   58,F
02D0:  GOTO   2AF
....................       } 
02D1:  GOTO   25C
....................    } 
....................  
.................... } 
02D2:  SLEEP

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
